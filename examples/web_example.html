<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ConvertKeylogApp Geometry API - Web Demo</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
            min-height: 100vh;
            padding: 20px;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 15px 35px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        .header {
            background: linear-gradient(45deg, #4CAF50, #2196F3);
            color: white;
            padding: 30px;
            text-align: center;
        }
        .header h1 { font-size: 2.5em; margin-bottom: 10px; }
        .header p { font-size: 1.1em; opacity: 0.9; }
        .main-content {
            padding: 30px;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
        }
        .form-section {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 25px;
            border: 2px solid #e9ecef;
        }
        .form-section h3 {
            color: #495057;
            margin-bottom: 20px;
            font-size: 1.3em;
            border-bottom: 2px solid #4CAF50;
            padding-bottom: 10px;
        }
        .form-group { margin-bottom: 20px; }
        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #495057;
        }
        .form-group select, .form-group input {
            width: 100%;
            padding: 12px;
            border: 2px solid #dee2e6;
            border-radius: 6px;
            font-size: 14px;
            transition: border-color 0.3s;
        }
        .form-group select:focus, .form-group input:focus {
            outline: none;
            border-color: #4CAF50;
            box-shadow: 0 0 0 3px rgba(76, 175, 80, 0.1);
        }
        .btn {
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: transform 0.2s, box-shadow 0.2s;
            width: 100%;
            margin-top: 10px;
        }
        .btn:hover { transform: translateY(-2px); box-shadow: 0 5px 15px rgba(76, 175, 80, 0.3); }
        .btn:disabled { background: #6c757d; cursor: not-allowed; transform: none; box-shadow: none; }
        .results-section {
            background: #fff;
            border-radius: 10px;
            padding: 25px;
            border: 2px solid #e9ecef;
        }
        .result-item {
            background: #f8f9fa;
            border-left: 4px solid #4CAF50;
            padding: 15px;
            margin-bottom: 15px;
            border-radius: 0 6px 6px 0;
        }
        .result-item h4 { color: #495057; margin-bottom: 8px; }
        .keylog {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 15px;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            font-size: 16px;
            word-break: break-all;
            position: relative;
        }
        .copy-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: #3498db;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
        }
        .error { background: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; padding: 15px; border-radius: 6px; margin-bottom: 15px; }
        .success { background: #d4edda; color: #155724; border: 1px solid #c3e6cb; padding: 15px; border-radius: 6px; margin-bottom: 15px; }
        .loading { text-align: center; padding: 20px; color: #6c757d; }
        .shape-inputs { display: none; margin-top: 15px; padding: 15px; background: #ffffff; border-radius: 6px; border: 1px solid #dee2e6; }
        .shape-inputs.active { display: block; }
        .examples-section {
            grid-column: 1 / -1;
            background: #e8f5e8;
            border-radius: 10px;
            padding: 25px;
            margin-top: 20px;
        }
        .example-btn {
            background: #17a2b8;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
            font-size: 14px;
        }
        .example-btn:hover { background: #138496; }
        .excel-section { background: #f8f9fa; border-radius: 10px; padding: 25px; border: 2px solid #e9ecef; margin-top: 20px; grid-column: 1 / -1; }
        .upload-zone { border: 2px dashed #4CAF50; border-radius: 10px; padding: 40px; text-align: center; cursor: pointer; transition: background-color 0.3s; }
        .upload-zone:hover { background-color: #f0f8f0; }
        .upload-icon { font-size: 3em; margin-bottom: 10px; }
        .file-info { background: white; padding: 20px; border-radius: 8px; margin: 20px 0; border: 1px solid #dee2e6; }
        .preview-table { width: 100%; border-collapse: collapse; margin-top: 10px; }
        .preview-table th, .preview-table td { border: 1px solid #dee2e6; padding: 8px; text-align: left; }
        .preview-table th { background-color: #f8f9fa; font-weight: 600; }
        .progress-section { background: white; padding: 20px; border-radius: 8px; margin: 20px 0; }
        .progress-bar { width: 100%; height: 20px; background-color: #e9ecef; border-radius: 10px; overflow: hidden; margin: 10px 0; }
        .progress-fill { height: 100%; background: linear-gradient(45deg, #4CAF50, #45a049); width: 0%; transition: width 0.3s ease; }
        .batch-results { background: #d4edda; border: 1px solid #c3e6cb; border-radius: 8px; padding: 20px; margin: 20px 0; }
        @media (max-width: 768px) {
            .main-content { grid-template-columns: 1fr; }
            .header h1 { font-size: 1.8em; }
        }
    </style>
        <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
</head>
<body>
<div class="container">
    <div class="header">
        <h1>üßÆ ConvertKeylogApp Geometry API</h1>
        <p>Web Demo - Chuy·ªÉn ƒë·ªïi b√†i to√°n h√¨nh h·ªçc th√†nh keylog m√°y t√≠nh Casio</p>
    </div>

    <div class="main-content">
        <div class="form-section">
            <h3>üìù Nh·∫≠p d·ªØ li·ªáu</h3>

            <div class="form-group">
                <label for="operation">Ph√©p to√°n:</label>
                <select id="operation" onchange="updateShapeOptions()">
                    <option value="">Ch·ªçn ph√©p to√°n...</option>
                </select>
            </div>

            <div class="form-group">
                <label for="shapeA">H√¨nh A:</label>
                <select id="shapeA" onchange="updateInputFields()">
                    <option value="">Ch·ªçn h√¨nh A...</option>
                </select>
            </div>

            <div id="inputsA" class="shape-inputs"></div>

            <div class="form-group">
                <label for="shapeB">H√¨nh B (t√πy ch·ªçn):</label>
                <select id="shapeB" onchange="updateInputFields()">
                    <option value="">Kh√¥ng c√≥</option>
                </select>
            </div>

            <div id="inputsB" class="shape-inputs"></div>

            <div class="form-group">
                <label for="version">Phi√™n b·∫£n m√°y t√≠nh:</label>
                <select id="version">
                    <option value="fx799">Casio fx-799</option>
                    <option value="fx800">Casio fx-800</option>
                    <option value="fx801">Casio fx-801</option>
                    <option value="fx802">Casio fx-802</option>
                    <option value="fx803">Casio fx-803</option>
                </select>
            </div>

            <button class="btn" onclick="processGeometry()" id="processBtn">üöÄ T√≠nh to√°n</button>
                            <button class="btn" onclick="renderShapeVisualization()" id="drawBtn">üé® V·∫Ω h√¨nh</button>
        </div>

        <div class="results-section">
            <h3>üìä K·∫øt qu·∫£</h3>
            <div id="results">
                <div class="loading">Nh·∫≠p d·ªØ li·ªáu v√† nh·∫•n "T√≠nh to√°n" ƒë·ªÉ xem k·∫øt qu·∫£...</div>
            </div>
        </div>

        <div class="examples-section">
            <h3>üí° V√≠ d·ª• nhanh</h3>
            <p style="margin-bottom: 15px;">Nh·∫•n v√†o m·ªôt v√≠ d·ª• ƒë·ªÉ t·ª± ƒë·ªông ƒëi·ªÅn d·ªØ li·ªáu:</p>

            <button class="example-btn" onclick="loadExample('distance_points')">Kho·∫£ng c√°ch 2 ƒëi·ªÉm</button>
            <button class="example-btn" onclick="loadExample('circle_area')">Di·ªán t√≠ch ƒë∆∞·ªùng tr√≤n</button>
            <button class="example-btn" onclick="loadExample('sphere_volume')">Th·ªÉ t√≠ch m·∫∑t c·∫ßu</button>
            <button class="example-btn" onclick="loadExample('line_plane_intersection')">Giao tuy·∫øn ƒë∆∞·ªùng th·∫≥ng - m·∫∑t ph·∫≥ng</button>
        </div>

        <div class="excel-section">
            <h3>üìä Excel Batch Processing</h3>

            <div class="upload-area" id="uploadArea">
                <input type="file" id="excelFile" accept=".xlsx,.xls" style="display: none;" onchange="handleFileUpload()">
                <div class="upload-zone" onclick="document.getElementById('excelFile').click()">
                    <div class="upload-icon">üìÅ</div>
                    <p>Click ƒë·ªÉ ch·ªçn file Excel ho·∫∑c k√©o th·∫£ v√†o ƒë√¢y</p>
                    <small>H·ªó tr·ª£ .xlsx v√† .xls</small>
                </div>
            </div>

            <div id="fileInfo" class="file-info" style="display: none;">
                <h4>üìã Th√¥ng tin file:</h4>
                <div id="fileDetails"></div>
                <div id="previewTable"></div>
            </div>

            <div id="processingConfig" class="processing-config" style="display: none;">
                <div class="form-group">
                    <label>Ph√©p to√°n cho batch:</label>
                    <select id="batchOperation"></select>
                </div>
                <div class="form-group">
                    <label>H√¨nh A:</label>
                    <select id="batchShapeA"></select>
                </div>
                <div class="form-group">
                    <label>H√¨nh B:</label>
                    <select id="batchShapeB"></select>
                </div>
                <button class="btn" onclick="processBatch()" id="processBatchBtn">üöÄ X·ª≠ l√Ω Batch</button>
            </div>

            <div id="batchProgress" class="progress-section" style="display: none;">
                <h4>‚è≥ ƒêang x·ª≠ l√Ω...</h4>
                <div class="progress-bar"><div class="progress-fill" id="progressFill"></div></div>
                <div id="progressText">0%</div>
            </div>

            <div id="batchResults" class="batch-results" style="display: none;">
                <h4>‚úÖ Ho√†n th√†nh!</h4>
                <div id="batchSummary"></div>
                <button class="btn" onclick="downloadResult()" id="downloadBtn">üíæ T·∫£i v·ªÅ k·∫øt qu·∫£</button>
            </div>
        </div>
    </div>
</div>

<script>
    const API_BASE = 'http://localhost:5000';
    let availableShapes = [];
    let availableOperations = [];
    let currentFilePath = null;
    let currentFileName = null;

    async function initApp() {
        try {
            const [shapesRes, operationsRes] = await Promise.all([
                fetch(`${API_BASE}/api/geometry/shapes`),
                fetch(`${API_BASE}/api/geometry/operations`)
            ]);
            const shapesData = await shapesRes.json();
            const operationsData = await operationsRes.json();
            availableShapes = shapesData.data || [];
            availableOperations = operationsData.data || [];
            populateOperations();
            populateShapes();
        } catch (error) {
            showError('Kh√¥ng th·ªÉ k·∫øt n·ªëi ƒë·∫øn API. Vui l√≤ng ki·ªÉm tra server ƒë√£ ch·∫°y ch∆∞a.');
            console.error('Init error:', error);
        }
    }

    function populateOperations() {
        const select = document.getElementById('operation');
        select.innerHTML = '<option value="">Ch·ªçn ph√©p to√°n...</option>';
        availableOperations.forEach(op => {
            const option = document.createElement('option');
            option.value = op;
            option.textContent = op;
            select.appendChild(option);
        });
    }

    function populateShapes() {
        const selectA = document.getElementById('shapeA');
        const selectB = document.getElementById('shapeB');
        selectA.innerHTML = '<option value="">Ch·ªçn h√¨nh A...</option>';
        selectB.innerHTML = '<option value="">Kh√¥ng c√≥</option>';
        availableShapes.forEach(shape => {
            const optionA = document.createElement('option');
            optionA.value = shape;
            optionA.textContent = shape;
            selectA.appendChild(optionA);
            const optionB = document.createElement('option');
            optionB.value = shape;
            optionB.textContent = shape;
            selectB.appendChild(optionB);
        });
    }

    async function updateShapeOptions() {
        const operation = document.getElementById('operation').value;
        if (!operation) return;
        try {
            const response = await fetch(`${API_BASE}/api/geometry/operations/${encodeURIComponent(operation)}/shapes`);
            const data = await response.json();
            const selectA = document.getElementById('shapeA');
            const selectB = document.getElementById('shapeB');
            selectA.innerHTML = '<option value="">Ch·ªçn h√¨nh A...</option>';
            (data.data || []).forEach(shape => {
                const option = document.createElement('option');
                option.value = shape;
                option.textContent = shape;
                selectA.appendChild(option);
            });
            selectB.innerHTML = '<option value="">Kh√¥ng c√≥</option>';
            if (!['Di·ªán t√≠ch', 'Th·ªÉ t√≠ch'].includes(operation)) {
                (data.data || []).forEach(shape => {
                    const option = document.createElement('option');
                    option.value = shape;
                    option.textContent = shape;
                    selectB.appendChild(option);
                });
            }
            updateInputFields();
        } catch (error) {
            console.error('Error updating shapes:', error);
        }
    }

    function updateInputFields() {
        const shapeA = document.getElementById('shapeA').value;
        const shapeB = document.getElementById('shapeB').value;
        updateShapeInputs('A', shapeA);
        updateShapeInputs('B', shapeB);
    }

    function updateShapeInputs(group, shape) {
        const container = document.getElementById(`inputs${group}`);
        container.innerHTML = '';
        if (!shape) { container.classList.remove('active'); return; }
        container.classList.add('active');
        if (shape === 'ƒêi·ªÉm') {
            container.innerHTML = `
                <label>T·ªça ƒë·ªô (x,y,z):</label>
                <input type="text" id="point_input_${group}" placeholder="V√≠ d·ª•: 1,2,3">
            `;
        } else if (shape === 'ƒê∆∞·ªùng th·∫≥ng') {
            container.innerHTML = `
                <label>ƒêi·ªÉm tr√™n ƒë∆∞·ªùng th·∫≥ng (x,y,z):</label>
                <input type="text" id="line_A${group === 'A' ? '1' : '2'}_${group}" placeholder="V√≠ d·ª•: 0,0,0">
                <label style="margin-top: 10px;">Vector ch·ªâ ph∆∞∆°ng (dx,dy,dz):</label>
                <input type="text" id="line_X${group === 'A' ? '1' : '2'}_${group}" placeholder="V√≠ d·ª•: 1,1,1">
            `;
        } else if (shape === 'M·∫∑t ph·∫≥ng') {
            container.innerHTML = `
                <label>H·ªá s·ªë a:</label>
                <input type="text" id="plane_a_${group}" placeholder="V√≠ d·ª•: 1">
                <label>H·ªá s·ªë b:</label>
                <input type="text" id="plane_b_${group}" placeholder="V√≠ d·ª•: 1">
                <label>H·ªá s·ªë c:</label>
                <input type="text" id="plane_c_${group}" placeholder="V√≠ d·ª•: 1">
                <label>H·∫±ng s·ªë d:</label>
                <input type="text" id="plane_d_${group}" placeholder="V√≠ d·ª•: 0">
            `;
        } else if (shape === 'ƒê∆∞·ªùng tr√≤n') {
            container.innerHTML = `
                <label>T√¢m ƒë∆∞·ªùng tr√≤n (x,y):</label>
                <input type="text" id="circle_center_${group}" placeholder="V√≠ d·ª•: 0,0">
                <label style="margin-top: 10px;">B√°n k√≠nh:</label>
                <input type="text" id="circle_radius_${group}" placeholder="V√≠ d·ª•: 5">
            `;
        } else if (shape === 'M·∫∑t c·∫ßu') {
            container.innerHTML = `
                <label>T√¢m m·∫∑t c·∫ßu (x,y,z):</label>
                <input type="text" id="sphere_center_${group}" placeholder="V√≠ d·ª•: 0,0,0">
                <label style="margin-top: 10px;">B√°n k√≠nh:</label>
                <input type="text" id="sphere_radius_${group}" placeholder="V√≠ d·ª•: 3">
            `;
        }
    }

    function collectInputData(group, shape) {
        const data = {};
        if (shape === 'ƒêi·ªÉm') {
            const pointInput = document.getElementById(`point_input_${group}`);
            if (pointInput) data.point_input = pointInput.value;
        } else if (shape === 'ƒê∆∞·ªùng th·∫≥ng') {
            const lineA = document.getElementById(`line_A${group === 'A' ? '1' : '2'}_${group}`);
            const lineX = document.getElementById(`line_X${group === 'A' ? '1' : '2'}_${group}`);
            if (lineA) data[`line_A${group === 'A' ? '1' : '2'}`] = lineA.value;
            if (lineX) data[`line_X${group === 'A' ? '1' : '2'}`] = lineX.value;
        } else if (shape === 'M·∫∑t ph·∫≥ng') {
            ['a','b','c','d'].forEach(coeff => {
                const input = document.getElementById(`plane_${coeff}_${group}`);
                if (input) data[`plane_${coeff}`] = input.value;
            });
        } else if (shape === 'ƒê∆∞·ªùng tr√≤n') {
            const circleCenter = document.getElementById(`circle_center_${group}`);
            const circleRadius = document.getElementById(`circle_radius_${group}`);
            if (circleCenter) data.circle_center = circleCenter.value;
            if (circleRadius) data.circle_radius = circleRadius.value;
        } else if (shape === 'M·∫∑t c·∫ßu') {
            const sphereCenter = document.getElementById(`sphere_center_${group}`);
            const sphereRadius = document.getElementById(`sphere_radius_${group}`);
            if (sphereCenter) data.sphere_center = sphereCenter.value;
            if (sphereRadius) data.sphere_radius = sphereRadius.value;
        }
        return data;
    }

    async function processGeometry() {
        const operation = document.getElementById('operation').value;
        const shapeA = document.getElementById('shapeA').value;
        const shapeB = document.getElementById('shapeB').value;
        const version = document.getElementById('version').value;
        if (!operation || !shapeA) { showError('Vui l√≤ng ch·ªçn ph√©p to√°n v√† h√¨nh A.'); return; }
        const dataA = collectInputData('A', shapeA);
        const dataB = shapeB ? collectInputData('B', shapeB) : {};
        const requestData = { operation, shape_A: shapeA, data_A: dataA, version };
        if (shapeB) { requestData.shape_B = shapeB; requestData.data_B = dataB; }
        document.getElementById('results').innerHTML = '<div class="loading">üîÑ ƒêang x·ª≠ l√Ω...</div>';
        document.getElementById('processBtn').disabled = true;
        try {
            const response = await fetch(`${API_BASE}/api/geometry/process`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(requestData)
            });
            const result = await response.json();
            if (result.status === 'success') displayResults(result.data);
            else showError(result.message || 'X·ª≠ l√Ω th·∫•t b·∫°i');
        } catch (error) {
            showError('L·ªói k·∫øt n·ªëi ƒë·∫øn API: ' + error.message);
            console.error('Processing error:', error);
        } finally {
            document.getElementById('processBtn').disabled = false;
        }
    }

    function displayResults(data) {
        const resultsContainer = document.getElementById('results');
        const keylogHtml = `
            <div class="result-item">
                <h4>üîë Keylog (${data.version}):</h4>
                <div class="keylog">
                    ${data.keylog}
                    <button class="copy-btn" onclick="copyToClipboard('${data.keylog}')">Copy</button>
                </div>
            </div>
            <div class="result-item">
                <h4>üìù Th√¥ng tin:</h4>
                <p><strong>Ph√©p to√°n:</strong> ${data.operation}</p>
                <p><strong>H√¨nh A:</strong> ${data.shape_A}</p>
                ${data.shape_B ? `<p><strong>H√¨nh B:</strong> ${data.shape_B}</p>` : ''}
                <p><strong>M√£ h√≥a A:</strong> [${(data.encoded_A || []).join(', ')}]</p>
                ${(data.encoded_B && data.encoded_B.length > 0) ? `<p><strong>M√£ h√≥a B:</strong> [${data.encoded_B.join(', ')}]</p>` : ''}
            </div>
            <div class="success">‚úÖ X·ª≠ l√Ω th√†nh c√¥ng! Sao ch√©p keylog v√† nh·∫≠p v√†o m√°y t√≠nh Casio.</div>
        `;
        resultsContainer.innerHTML = keylogHtml;
    }

    function showError(message) {
        const resultsContainer = document.getElementById('results');
        resultsContainer.innerHTML = `<div class="error">‚ùå ${message}</div>`;
    }

    function copyToClipboard(text) {
        navigator.clipboard.writeText(text).then(() => {
            const btn = event.target;
            const originalText = btn.textContent;
            btn.textContent = 'Copied!';
            btn.style.background = '#27ae60';
            setTimeout(() => {
                btn.textContent = originalText;
                btn.style.background = '#3498db';
            }, 1500);
        }).catch(err => {
            console.error('Copy failed:', err);
            alert('Kh√¥ng th·ªÉ copy. Vui l√≤ng copy th·ªß c√¥ng.');
        });
    }

    const examples = {
        distance_points: {
            operation: 'Kho·∫£ng c√°ch',
            shapeA: 'ƒêi·ªÉm',
            shapeB: 'ƒêi·ªÉm',
            dataA: { point_input: '1,2,3' },
            dataB: { point_input: '4,5,6' }
        },
        circle_area: {
            operation: 'Di·ªán t√≠ch',
            shapeA: 'ƒê∆∞·ªùng tr√≤n',
            dataA: { circle_center: '0,0', circle_radius: 'sqrt(5)' }
        },
        sphere_volume: {
            operation: 'Th·ªÉ t√≠ch',
            shapeA: 'M·∫∑t c·∫ßu',
            dataA: { sphere_center: '0,0,0', sphere_radius: '3' }
        },
        line_plane_intersection: {
            operation: 'T∆∞∆°ng giao',
            shapeA: 'ƒê∆∞·ªùng th·∫≥ng',
            shapeB: 'M·∫∑t ph·∫≥ng',
            dataA: { line_A1: '0,0,0', line_X1: '1,1,1' },
            dataB: { plane_a: '1', plane_b: '1', plane_c: '1', plane_d: '0' }
        }
    };

    function loadExample(exampleKey) {
        const example = examples[exampleKey];
        if (!example) return;
        document.getElementById('operation').value = example.operation;
        updateShapeOptions().then(() => {
            document.getElementById('shapeA').value = example.shapeA;
            if (example.shapeB) {
                document.getElementById('shapeB').value = example.shapeB;
            }
            updateInputFields();
            setTimeout(() => {
                Object.entries(example.dataA).forEach(([key, value]) => {
                    const input = document.getElementById(`${key}_A`);
                    if (input) input.value = value;
                });
                if (example.dataB) {
                    Object.entries(example.dataB).forEach(([key, value]) => {
                        const input = document.getElementById(`${key}_B`);
                        if (input) input.value = value;
                    });
                }
            }, 100);
        });
    }

    async function handleFileUpload() {
        const fileInput = document.getElementById('excelFile');
        const file = fileInput.files[0];
        if (!file) return;
        const formData = new FormData();
        formData.append('file', file);
        try {
            const response = await fetch(`${API_BASE}/api/geometry/excel/upload`, {
                method: 'POST',
                body: formData
            });
            const result = await response.json();
            if (result.status === 'success') {
                currentFilePath = result.filepath;
                currentFileName = result.filename;
                displayFileInfo(result);
            } else {
                showError('Upload failed: ' + result.message);
            }
        } catch (error) {
            showError('Upload error: ' + error.message);
        }
    }

    function displayFileInfo(fileData) {
        const fileInfo = document.getElementById('fileInfo');
        const fileDetails = document.getElementById('fileDetails');
        const previewTable = document.getElementById('previewTable');
        fileDetails.innerHTML = `
            <p><strong>T√™n file:</strong> ${fileData.filename}</p>
            <p><strong>T·ªïng s·ªë d√≤ng:</strong> ${fileData.total_rows}</p>
            <p><strong>K√≠ch th∆∞·ªõc:</strong> ${fileData.file_size_mb} MB</p>
        `;
        let tableHtml = '<h5>Preview (5 d√≤ng ƒë·∫ßu):</h5><table class="preview-table"><thead><tr>';
        fileData.columns.forEach(col => {
            tableHtml += `<th>${col}</th>`;
        });
        tableHtml += '</tr></thead><tbody>';
        fileData.preview.forEach(row => {
            tableHtml += '<tr>';
            fileData.columns.forEach(col => {
                tableHtml += `<td>${row[col] || ''}</td>`;
            });
            tableHtml += '</tr>';
        });
        tableHtml += '</tbody></table>';
        previewTable.innerHTML = tableHtml;
        fileInfo.style.display = 'block';
        document.getElementById('processingConfig').style.display = 'block';
        populateBatchConfig();
    }

    function populateBatchConfig() {
        document.getElementById('batchOperation').innerHTML = document.getElementById('operation').innerHTML;
        document.getElementById('batchShapeA').innerHTML = document.getElementById('shapeA').innerHTML;
        document.getElementById('batchShapeB').innerHTML = document.getElementById('shapeB').innerHTML;
    }

    async function processBatch() {
        const operation = document.getElementById('batchOperation').value;
        const shapeA = document.getElementById('batchShapeA').value;
        const shapeB = document.getElementById('batchShapeB').value;
        if (!operation || !shapeA || !currentFilePath) {
            showError('Vui l√≤ng ch·ªçn ƒë·∫ßy ƒë·ªß th√¥ng tin v√† upload file');
            return;
        }
        const requestData = {
            filepath: currentFilePath,
            operation: operation,
            shape_A: shapeA,
            shape_B: shapeB || null
        };
        try {
            showBatchProgress();
            const response = await fetch(`${API_BASE}/api/geometry/excel/process`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(requestData)
            });
            const result = await response.json();
            if (result.status === 'success') {
                showBatchResults(result);
            } else {
                showError('Batch processing failed: ' + result.message);
            }
        } catch (error) {
            showError('Processing error: ' + error.message);
        }
    }

    function showBatchProgress() {
        document.getElementById('batchProgress').style.display = 'block';
        document.getElementById('processBatchBtn').disabled = true;
        let progress = 0;
        const interval = setInterval(() => {
            progress += Math.random() * 20;
            if (progress >= 90) {
                clearInterval(interval);
                progress = 90;
            }
            updateProgress(progress);
        }, 500);
    }

    function updateProgress(percent) {
        const fill = document.getElementById('progressFill');
        const text = document.getElementById('progressText');
        fill.style.width = percent + '%';
        text.textContent = Math.round(percent) + '%';
    }

    function showBatchResults(result) {
        document.getElementById('batchProgress').style.display = 'none';
        document.getElementById('batchResults').style.display = 'block';
        const summary = document.getElementById('batchSummary');
        summary.innerHTML = `
            <p><strong>ƒê√£ x·ª≠ l√Ω:</strong> ${result.processed_rows} d√≤ng</p>
            <p><strong>Th√†nh c√¥ng:</strong> ${result.successful_rows} d√≤ng</p>
            <p><strong>L·ªói:</strong> ${result.error_count} d√≤ng</p>
            <p><strong>File k·∫øt qu·∫£:</strong> ${result.output_file}</p>
        `;
        if (result.errors && result.errors.length > 0) {
            summary.innerHTML += '<p><strong>Chi ti·∫øt l·ªói:</strong></p><ul>';
            result.errors.slice(0, 5).forEach(error => {
                summary.innerHTML += `<li>${error}</li>`;
            });
            if (result.errors.length > 5) {
                summary.innerHTML += `<li>... v√† ${result.errors.length - 5} l·ªói kh√°c</li>`;
            }
            summary.innerHTML += '</ul>';
        }
        window.resultFilePath = result.output_file;
    }

    function downloadResult() {
        if (window.resultFilePath) {
            const filename = window.resultFilePath.split('/').pop();
            window.open(`${API_BASE}/api/geometry/excel/download/${filename}`, '_blank');
        }
    }

    window.addEventListener('load', initApp);
</script>
    
    <!-- VISUALIZATION SECTION: Real-time 3D Geometry Canvas -->
    <script>
        // Initialize visualization canvas on page load
        function initVisualizationCanvas() {
            const canvas = document.createElement('div');
            canvas.id = 'geometryCanvas';
            canvas.style.cssText = 'width:100%; height:500px; background:#f0f0f0; border-radius:10px; margin-top:30px; border:2px solid #ddd;';
            
            const container = document.querySelector('.main-content');
            if (container) {
                container.appendChild(canvas);
            } else {
                document.querySelector('.container').appendChild(canvas);
            }
            
            // Initialize empty plot
            const layout = {
                title: 'üé® Real-time 3D Geometry Visualization',
                scene: {
                    xaxis: { title: 'X Axis', showgrid: true },
                    yaxis: { title: 'Y Axis', showgrid: true },
                    zaxis: { title: 'Z Axis', showgrid: true }
                },
                autosize: true,
                margin: { l: 0, r: 0, t: 40, b: 0 }
            };
            
            const data = [];
            Plotly.newPlot('geometryCanvas', data, layout, { responsive: true });
        }
        
        // Visualize geometry shapes
        function visualizeGeometry(geometryData) {
            if (!geometryData || geometryData.length === 0) {
                console.log('No geometry data to visualize');
                return;
            }
            
            const traces = [];
            
            geometryData.forEach((item, index) => {
                const type = item.type?.toLowerCase();
                
                if (type === 'point') {
                    traces.push({
                        x: [item.x],
                        y: [item.y],
                        z: [item.z],
                        mode: 'markers',
                        type: 'scatter3d',
                        name: `Point ${index + 1}`,
                        marker: { size: 8, color: '#FF6B6B' }
                    });
                } else if (type === 'line') {
                    traces.push({
                        x: [item.x1, item.x2],
                        y: [item.y1, item.y2],
                        z: [item.z1, item.z2],
                        mode: 'lines',
                        type: 'scatter3d',
                        name: `Line ${index + 1}`,
                        line: { color: '#4ECDC4', width: 4 }
                    });
                }
            });
            
            if (traces.length > 0) {
                Plotly.react('geometryCanvas', traces, {}, { responsive: true });
            }
        }
        
        // Initialize on page load
        document.addEventListener('DOMContentLoaded', initVisualizationCanvas);
        
        // Demo: Display sample geometry when visualization loads
        function loadDemoGeometry() {
            setTimeout(() => {
                const demoGeometry = [
                    { type: 'point', x: 1, y: 1, z: 1 },
                    { type: 'point', x: 2, y: 2, z: 2 },
                    { type: 'point', x: 3, y: 1, z: 2 },
                    { type: 'line', x1: 0, y1: 0, z1: 0, x2: 5, y2: 5, z2: 5 },
                    { type: 'line', x1: 0, y1: 0, z1: 5, x2: 5, y2: 5, z2: 0 },
                    { type: 'line', x1: 5, y1: 0, z1: 0, x2: 0, y2: 5, z2: 5 }
                ];
                visualizeGeometry(demoGeometry);
            }, 500);
        }
            // Parse raw form data to match createGeometryTrace() expectations
    function parseGeometryData(type, rawData) {
        if (!type || !rawData) return null;
        
        try {
            switch(type) {
                case 'ƒêi·ªÉm':
                case 'point':
                    const pointStr = rawData.point_input || rawData.point_center;
                    const coords = pointStr.split(',').map(s => parseFloat(s.trim()));
                    return { x: coords[0], y: coords[1], z: coords[2] };
                    
                case 'ƒê∆∞·ªùng th·∫≥ng':
                case 'line':
                    const p1Str = rawData.line_p1;
                    const p2Str = rawData.line_p2;
                    const p1 = p1Str.split(',').map(s => parseFloat(s.trim()));
                    const p2 = p2Str.split(',').map(s => parseFloat(s.trim()));
                    return { x1: p1[0], y1: p1[1], z1: p1[2], dx: p2[0]-p1[0], dy: p2[1]-p1[1], dz: p2[2]-p1[2] };
                    
                case 'M·∫∑t ph·∫≥ng':
                case 'plane':
                    return {
                        a: parseFloat(rawData.plane_a),
                        b: parseFloat(rawData.plane_b),
                        c: parseFloat(rawData.plane_c),
                        d: parseFloat(rawData.plane_d)
                    };
                    
                case 'ƒê∆∞·ªùng tr√≤n':
                case 'circle':
                    const circleCenter = rawData.circle_center.split(',').map(s => parseFloat(s.trim()));
                    return { cx: circleCenter[0], cy: circleCenter[1], r: parseFloat(rawData.circle_radius) };
                    
                case 'M·∫∑t c·∫ßu':
                case 'sphere':
                    const sphereCenter = rawData.sphere_center.split(',').map(s => parseFloat(s.trim()));
                    return { cx: sphereCenter[0], cy: sphereCenter[1], cz: sphereCenter[2], r: parseFloat(rawData.sphere_radius) };
                    
                default:
                    return rawData;
            }
        } catch(e) {
            console.error('Error parsing geometry data:', e);
            return null;
        }
    }

            // Draw shape visualization based on form inputs
    function renderShapeVisualization() {
        try {
            const shapeA = document.getElementById('shapeA').value;
            const shapeB = document.getElementById('shapeB').value;
            const traces = [];
            
            // Process shapeA
            if (shapeA !== 'none') {
                const dataA = collectInputData('A', shapeA);
                if (dataA) {
                                        // Parse raw form data to match createGeometryTrace expectations
                    const parsedDataA = parseGeometryData(shapeA, dataA);
                    const traceA = createGeometryTrace(shapeA, parsedDataA, '#4CAF50');
                    if (traceA) traces.push(traceA);
                }
            }
            
            // Process shapeB
            if (shapeB !== 'none') {
                const dataB = collectInputData('B', shapeB);
                                    // Parse raw form data to match createGeometryTrace expectations
                    const parsedDataB = parseGeometryData(shapeB, dataB);
                if (dataB) {
                    const traceB = createGeometryTrace(shapeB, parsedDataB, '#2196F3');
                    if (traceB) traces.push(traceB);
                }
            }
            
            // Draw all traces
            if (traces.length > 0) {
                Plotly.react('geometryCanvas', traces, {}, { responsive: true });
            } else {
                alert('Vui l√≤ng ch·ªçn h√¨nh h·ªçc v√† nh·∫≠p d·ªØ li·ªáu!');
            }
        } catch (e) {
            console.error('L·ªói v·∫Ω h√¨nh:', e);
            alert('L·ªói khi v·∫Ω h√¨nh: ' + e.message);
        }
    }
    
    function createGeometryTrace(type, data, color) {
        try {
            switch(type) {
                case 'point':
                    return {
                        x: [data.x || 0],
                        y: [data.y || 0],
                        z: [data.z || 0],
                        mode: 'markers',
                        marker: { size: 8, color: color },
                        name: 'ƒêi·ªÉm',
                        type: 'scatter3d'
                    };
                    
                case 'line':
                    const x1 = data.x1 || 0, y1 = data.y1 || 0, z1 = data.z1 || 0;
                    const dx = data.dx || 1, dy = data.dy || 0, dz = data.dz || 0;
                    const t_vals = [-5, 5];
                    return {
                        x: t_vals.map(t => x1 + t * dx),
                        y: t_vals.map(t => y1 + t * dy),
                        z: t_vals.map(t => z1 + t * dz),
                        mode: 'lines',
                        line: { color: color, width: 2 },
                        name: 'ƒê∆∞·ªùng th·∫≥ng',
                        type: 'scatter3d'
                    };
                    
                case 'plane':
                    const a = data.a || 1, b = data.b || 1, c = data.c || 1, d = data.d || 0;
                    const grid_size = 5;
                    const x_plane = [], y_plane = [], z_plane = [];
                    for (let i = -grid_size; i <= grid_size; i++) {
                        for (let j = -grid_size; j <= grid_size; j++) {
                            x_plane.push(i);
                            y_plane.push(j);
                            z_plane.push(-(a*i + b*j + d) / (c || 1));
                        }
                    }
                    return {
                        x: x_plane,
                        y: y_plane,
                        z: z_plane,
                        mode: 'markers',
                        marker: { size: 2, color: color, opacity: 0.6 },
                        name: 'M·∫∑t ph·∫≥ng',
                        type: 'scatter3d'
                    };
                    
                case 'circle':
                    const cx = data.cx || 0, cy = data.cy || 0, r = data.r || 1;
                    const angles = [];
                    for (let i = 0; i <= 360; i += 5) angles.push(i * Math.PI / 180);
                    return {
                        x: angles.map(a => cx + r * Math.cos(a)),
                        y: angles.map(a => cy + r * Math.sin(a)),
                        mode: 'lines',
                        line: { color: color, width: 2 },
                        name: 'ƒê∆∞·ªùng tr√≤n',
                        type: 'scatter'
                    };
                    
                case 'sphere':
                    const cx_s = data.cx || 0, cy_s = data.cy || 0, cz_s = data.cz || 0, r_s = data.r || 1;
                    const x_s = [], y_s = [], z_s = [];
                    for (let lat = 0; lat <= Math.PI; lat += Math.PI / 10) {
                        for (let lng = 0; lng <= 2 * Math.PI; lng += Math.PI / 10) {
                            x_s.push(cx_s + r_s * Math.sin(lat) * Math.cos(lng));
                            y_s.push(cy_s + r_s * Math.sin(lat) * Math.sin(lng));
                            z_s.push(cz_s + r_s * Math.cos(lat));
                        }
                    }
                    return {
                        x: x_s,
                        y: y_s,
                        z: z_s,
                        mode: 'markers',
                        marker: { size: 2, color: color, opacity: 0.5 },
                        name: 'H√¨nh c·∫ßu',
                        type: 'scatter3d'
                    };
            }
        } catch (e) {
            console.error('L·ªói t·∫°o h√¨nh:', type, e);
        }
        return null;
    }

        // Auto-load demo geometry
        setT// setTimeout(loadDemoGeometry, 1000); // Disabled: user should click 'V·∫Ω h√¨nh' button to draw
    </script>
</body>
</html>
