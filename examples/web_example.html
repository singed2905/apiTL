<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ConvertKeylogApp Geometry API - Web Demo</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <style>
        /* ... CSS ph·∫ßn c≈© ... */
        #geometryCanvas {margin-top:35px; width: 100%; height: 410px; border-radius: 10px; background: #f8f9fa; border: 2px solid #dde4ea;}
        #canvasStatus {padding: 12px; color: #1976D2; background: #e3f2fd; border-radius: 5px; margin-top:10px;}
    </style>
</head>
<body>
<div class="container">
    <!-- ...HTML Giao di·ªán c≈© ... -->
    <div class="main-content">
        <!-- ... c√°c ph·∫ßn nh·∫≠p li·ªáu & k·∫øt qu·∫£ ... -->
    </div>
    <!-- B·ªî SUNG Visualization Canvas Section -->
    <div class="visualization-section">
        <h3>üé® Visualization Canvas</h3>
        <div id="geometryCanvas"></div>
        <div id="canvasStatus">Nh·∫≠p d·ªØ li·ªáu, nh·∫•n T√≠nh to√°n ƒë·ªÉ tr·ª±c quan h√≥a h√¨nh h·ªçc.</div>
    </div>
</div>
<script>
// ------- PH·∫¶N M√É Visualization CANVAS -----------
function parseCoordinates(str, dim=3) {
    if (!str) return null;
    const vals = str.split(',').map(s => {
        s = s.trim().replace('sqrt', 'Math.sqrt').replace('pi', 'Math.PI');
        try { return eval(s); } catch { return parseFloat(s)||0; }
    });
    while(vals.length < dim) vals.push(0);
    return vals.slice(0, dim);
}
function visualizeGeometry() {
    let traces=[];
    const shapeA = document.getElementById('shapeA').value;
    const shapeB = document.getElementById('shapeB').value;
    const dataA = collectInputData('A', shapeA);
    const dataB = shapeB ? collectInputData('B', shapeB) : {};
    // SHAPE A
    if(shapeA==='ƒêi·ªÉm') {
        const coords = parseCoordinates(dataA.point_input);
        if(coords) traces.push({type:'scatter3d',mode:'markers',x:[coords[0]],y:[coords[1]],z:[coords[2]],marker:{size:11,color:'#43a047'},name:'ƒêi·ªÉm A'});
    } else if(shapeA==='ƒê∆∞·ªùng th·∫≥ng') {
        const p = parseCoordinates(dataA.line_A1), v = parseCoordinates(dataA.line_X1);
        let x=[],y=[],z=[]; for(let t=-10;t<=10;t+=.13){x.push(p[0]+t*v[0]); y.push(p[1]+t*v[1]); z.push(p[2]+t*v[2]);}
        traces.push({type:'scatter3d',mode:'lines',x,y,z,line:{color:'#1976d2',width:4},name:'ƒê∆∞·ªùng th·∫≥ng A'});
        traces.push({type:'scatter3d',mode:'markers',x:[p[0]],y:[p[1]],z:[p[2]],marker:{size:8,color:'#43a047'},name:'G·ªëc A',showlegend:false});
    } else if(shapeA==='M·∫∑t ph·∫≥ng') {
        const a = parseFloat(dataA.plane_a)||0,b = parseFloat(dataA.plane_b)||0,c = parseFloat(dataA.plane_c)||0,d = parseFloat(dataA.plane_d)||0;
        const size=10,step=1; let x_mesh=[],y_mesh=[],z_mesh=[];
        for(let xi=-size;xi<=size;xi+=step){ let x_row=[],y_row=[],z_row=[];
            for(let yi=-size;yi<=size;yi+=step){x_row.push(xi);y_row.push(yi);
                if(Math.abs(c)>0.01)z_row.push(-(a*xi+b*yi+d)/c); else if(Math.abs(b)>0.01)y_row[y_row.length-1]=-(a*xi+c*yi+d)/b,z_row.push(yi);else z_row.push(0);
            } x_mesh.push(x_row); y_mesh.push(y_row); z_mesh.push(z_row);
        } traces.push({type:'surface',x:x_mesh,y:y_mesh,z:z_mesh,colorscale:[[0,'#1976d2'],[1,'#43a047']],opacity:0.7,showscale:false,name:'M·∫∑t ph·∫≥ng A',hoverinfo:'name'});
    } else if(shapeA==='ƒê∆∞·ªùng tr√≤n') {
        const center = parseCoordinates(dataA.circle_center,2), r = parseFloat(dataA.circle_radius)||1;
        let x=[],y=[],z=[]; for(let t=0;t<=2*Math.PI;t+=.09){x.push(center[0]+r*Math.cos(t));y.push(center[1]+r*Math.sin(t));z.push(0);}
        traces.push({type:'scatter3d',mode:'lines',x,y,z,line:{color:'#d81b60',width:4},name:'ƒê∆∞·ªùng tr√≤n A'});
        traces.push({type:'scatter3d',mode:'markers',x:[center[0]],y:[center[1]],z:[0],marker:{size:10,color:'#43a047'},name:'T√¢m A',showlegend:false});
    } else if(shapeA==='M·∫∑t c·∫ßu') {
        const center = parseCoordinates(dataA.sphere_center), r=parseFloat(dataA.sphere_radius)||1;
        let x_mesh=[],y_mesh=[],z_mesh=[];
        for(let phi=0;phi<=Math.PI;phi+=Math.PI/20){ let x_row=[],y_row=[],z_row=[];
            for(let theta=0;theta<=2*Math.PI;theta+=Math.PI/20){
                x_row.push(center[0]+r*Math.sin(phi)*Math.cos(theta));
                y_row.push(center[1]+r*Math.sin(phi)*Math.sin(theta));
                z_row.push(center[2]+r*Math.cos(phi));
            }x_mesh.push(x_row);y_mesh.push(y_row);z_mesh.push(z_row);
        } traces.push({type:'surface',x:x_mesh,y:y_mesh,z:z_mesh,colorscale:[[0,'#1976d2'],[1,'#43a047']],opacity:0.6,showscale:false,name:'M·∫∑t c·∫ßu A',hoverinfo:'name'});
        traces.push({type:'scatter3d',mode:'markers',x:[center[0]],y:[center[1]],z:[center[2]],marker:{size:9,color:'#43a047'},name:'T√¢m A',showlegend:false});
    }
    // SHAPE B -- n·∫øu c√≥
    if(shapeB) {
      if(shapeB==='ƒêi·ªÉm') {
          const coords = parseCoordinates(dataB.point_input);
          if(coords) traces.push({type:'scatter3d',mode:'markers',x:[coords[0]],y:[coords[1]],z:[coords[2]],marker:{size:10,color:'#E91E63'},name:'ƒêi·ªÉm B'});
      } else if(shapeB==='ƒê∆∞·ªùng th·∫≥ng') {
          const p = parseCoordinates(dataB.line_A2), v = parseCoordinates(dataB.line_X2);
          let x=[],y=[],z=[]; for(let t=-10;t<=10;t+=.13){x.push(p[0]+t*v[0]); y.push(p[1]+t*v[1]); z.push(p[2]+t*v[2]);}
          traces.push({type:'scatter3d',mode:'lines',x,y,z,line:{color:'#C2185B',width:4},name:'ƒê∆∞·ªùng th·∫≥ng B'});
          traces.push({type:'scatter3d',mode:'markers',x:[p[0]],y:[p[1]],z:[p[2]],marker:{size:8,color:'#E91E63'},name:'G·ªëc B',showlegend:false});
      } else if(shapeB==='M·∫∑t ph·∫≥ng') {
          const a = parseFloat(dataB.plane_a)||0,b = parseFloat(dataB.plane_b)||0,c = parseFloat(dataB.plane_c)||0,d = parseFloat(dataB.plane_d)||0;
          const size=10,step=1; let x_mesh=[],y_mesh=[],z_mesh=[];
          for(let xi=-size;xi<=size;xi+=step){ let x_row=[],y_row=[],z_row=[];
              for(let yi=-size;yi<=size;yi+=step){x_row.push(xi);y_row.push(yi);
                  if(Math.abs(c)>0.01)z_row.push(-(a*xi+b*yi+d)/c); else if(Math.abs(b)>0.01)y_row[y_row.length-1]=-(a*xi+c*yi+d)/b,z_row.push(yi);else z_row.push(0);
              } x_mesh.push(x_row); y_mesh.push(y_row); z_mesh.push(z_row);
          } traces.push({type:'surface',x:x_mesh,y:y_mesh,z:z_mesh,colorscale:[[0,'#E91E63'],[1,'#C2185B']],opacity:0.5,showscale:false,name:'M·∫∑t ph·∫≥ng B',hoverinfo:'name'});
      } else if(shapeB==='ƒê∆∞·ªùng tr√≤n') {
          const center = parseCoordinates(dataB.circle_center,2), r = parseFloat(dataB.circle_radius)||1;
          let x=[],y=[],z=[]; for(let t=0;t<=2*Math.PI;t+=.09){x.push(center[0]+r*Math.cos(t));y.push(center[1]+r*Math.sin(t));z.push(0);}
          traces.push({type:'scatter3d',mode:'lines',x,y,z,line:{color:'#C2185B',width:4},name:'ƒê∆∞·ªùng tr√≤n B'});
          traces.push({type:'scatter3d',mode:'markers',x:[center[0]],y:[center[1]],z:[0],marker:{size:10,color:'#E91E63'},name:'T√¢m B',showlegend:false});
      } else if(shapeB==='M·∫∑t c·∫ßu') {
          const center = parseCoordinates(dataB.sphere_center), r=parseFloat(dataB.sphere_radius)||1;
          let x_mesh=[],y_mesh=[],z_mesh=[];
          for(let phi=0;phi<=Math.PI;phi+=Math.PI/20){ let x_row=[],y_row=[],z_row=[];
              for(let theta=0;theta<=2*Math.PI;theta+=Math.PI/20){
                  x_row.push(center[0]+r*Math.sin(phi)*Math.cos(theta));
                  y_row.push(center[1]+r*Math.sin(phi)*Math.sin(theta));
                  z_row.push(center[2]+r*Math.cos(phi));
              }x_mesh.push(x_row);y_mesh.push(y_row);z_mesh.push(z_row);
          } traces.push({type:'surface',x:x_mesh,y:y_mesh,z:z_mesh,colorscale:[[0,'#E91E63'],[1,'#C2185B']],opacity:0.5,showscale:false,name:'M·∫∑t c·∫ßu B',hoverinfo:'name'});
          traces.push({type:'scatter3d',mode:'markers',x:[center[0]],y:[center[1]],z:[center[2]],marker:{size:9,color:'#E91E63'},name:'T√¢m B',showlegend:false});
      }
    }
    if(!traces.length){document.getElementById('canvasStatus').textContent='Kh√¥ng c√≥ d·ªØ li·ªáu h·ª£p l·ªá!'; Plotly.purge('geometryCanvas'); return;}
    Plotly.newPlot('geometryCanvas', traces, {
        title:'Visualization',
        scene: {xaxis:{title:'X',range:[-12,12],showgrid:true},yaxis:{title:'Y',range:[-12,12],showgrid:true},zaxis:{title:'Z',range:[-12,12],showgrid:true},aspectmode:'cube'},
        margin:{l:0,r:0,b:0,t:40},showlegend:true
    },{responsive:true});
    document.getElementById('canvasStatus').textContent='V·∫Ω tr·ª±c quan th√†nh c√¥ng!';
}
// B·ªï sung g·ªçi v·∫Ω m·ªói l·∫ßn T√≠nh to√°n xong
const oldDisplayResults = displayResults;
displayResults = function(data){ oldDisplayResults(data); visualizeGeometry(); };
</script>
<!-- ...ph·∫ßn HTML ƒë√≥ng -->
